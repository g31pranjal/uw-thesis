\chapter{Columnar Storage}
\label{c:columnar-storage}

In this section, we explore the application of columnar data structures for different storage components of the \gls{gdbms}. 

Section \ref{sec:vertex-property-columns} describes the design of columns for vertex properties. In section \ref{sec:edge-property-columns}, we state the limitations of using sub-optimal approaches to storing edge properties in columns. We introduce \emph{edge property lists} for storing edge properties in a way efficient for storage and access. The above sections also describe a new and more compact identification scheme for vertex and edges in the system. Our new identification scheme replace 8-byte \texttt{vertexID}s and \texttt{edgeIDs}. Section \ref{sec:adjacency-lists} describes adjacency lists in light of columnar storage. We end by discussing several storage optimizations for our new data structures and identification scheme in order the memory footprint without giving up query performance.

\section{Columns for Vertex properties}
\label{sec:vertex-property-columns}

\begin{figure}
	\vspace{-15pt}
	\hfill\includegraphics[scale=0.85]{img/vpcols}\hspace*{\fill}
	\caption{Vertex property columns for the graph in Fig.~\ref{fig:runn}.}
	\label{fig:vpcols}
	\vspace{-8pt}
\end{figure}

Columnar data-structures can be directly used for storing vertex properties. Let $(lv_1, vl_2, ...)$ be the vertex labels in a graph. Then, $lv_i$ determines $p_{i,1},  p_{i,2}, ...$, where $p_{i, j}$ is a structured vertex property of $lv_i$, having a datatype $d_{i,j}$. We define a \emph{vertex property column}, $CV_{i,j}$, for each $p_{i,j}$, having a fixed data type $d_{i,j}$. Each column stores the value of a single property $p_{i,j}$ for all vertices having $lv_i$ at consecutive locations. The collection of columns of a particular vertex label $lv_i$ is called the column family, $FCV_i$. By its structure, a column is a single-dimensional array of \emph{fixed-width} elements. We store one vertex property per element in a column. The property value of a vertex can be directly read using positional offset in the column.

Vertex property columns are not ordered, not even by the \texttt{vertexID}. New insertions to a column are performed by simply appending at the end of the column. However, we ensure that all property values of a particular vertex $v$, having label $lv_i$, is located at the same positional offset in their resepective columns of the family $FCV_i$. We call this positional offset, \emph{(vertex) label-level postional offset} of vertex $v$. This postional offset can be thought of as the identity of $v$ within its vertex label $lv_i$, that is used to reference properties of $v$. Further, the global identity of $v$ can be given by \textit{(vertex label, label-level positional offset)} pair. 

Figure~\ref{fig:vpcols} shows the set of vertex property columns for the graph in Fig.~\ref{fig:runn}. It has 2 column families, one for each vertex label in the system, with a column for each structured property of the label. The \texttt{vertexID}s on the right of a column family indicates the offset at which the properties of a vertex are located in the columns.

Accessing a vertex $v$'s properties involves resolving $v$'s \texttt{vertexID} to its vertex label and its label-level positional offset. Except, this is an added computational overhead that we will incur each time a property is fetched from a vertex property column. Also, we need to maintain a \texttt{vertexID} to vertex label and positional offset map. To avoid maintaining this extra map and resolving \texttt{vertexID}, we identify a vertex by a \emph{\textbf{(vertex label, label-level positional offset)}} tuple in the system in place of 8-byte \texttt{vertexID}. This makes accessing the properties simple and intuitive in the sense that now, positional offset is the part of vertex identity itself. However, the downside of using the new vertex identification scheme is that we need to materilaize 2 pieces of information in the adjacency lists - a 4 byte vertex label and an 8 byte positional offset, compared to only 8 byte \texttt{vertexID} by the earlier scheme. This increases the memory overhead by 1.25x. We introduce several storge optimizations to counter the surge in adjacency lists size in section \ref{sec:storage-optimizations}.

\section{Columns for Edge properties}
\label{sec:edge-property-columns}

Inferring from \ref{ssec:edges-ordered}, 1) the edges are ordered in the adjacency lists, 2) edges are read by the \texttt{E/I} operators in the order in which they appear in the adjacency lists, and, 3) edge properties are read in the order in which edges are read. The access pattern of edge properties calls for storing edge properties in the order of edges. This will allow orderly reads and enables a query to benefit from cache locality while reading edge properties. To adhere to 2 edge orderings, each edge proerty has to be replicated twice with the edge, once by the forward adjacency list of edge's source vertex and then again by the backward adjacency list of the destination vertex. We present two naive solutions, that can be seen as opposite ends of the spectrum, optimizing the system for \emph{storage} and \emph{performance} respectively:

\begin{figure}
	\vspace{-25pt}
	\hspace*{-20pt}
	\begin{subfigure}{0.45\textwidth}
		\vspace{8pt}
		\centering
		\includegraphics[scale=0.8]{img/sol1}
		\captionsetup{justification=centering}
		\caption{Sol 1: (Unordered, No Replication)}
		\label{fig:sol1}
	\end{subfigure}
	\begin{subfigure}{0.55\textwidth}
		\centering
		\includegraphics[scale=0.8]{img/sol2}
		\captionsetup{justification=centering}
		\caption{Sol 2: (Ordered, Replication)}
		\label{fig:sol2}
	\end{subfigure}
	\captionsetup{justification=centering}
	\caption{Edge property columns in Solution 1 and 2 for \texttt{since} property for the graph in Fig.~\ref{fig:runn}.}
	\label{fig:sol1and2}
	\vspace{-8pt}
\end{figure}

\vspace{-12pt}
\subparagraph{Solution 1: (Unordered, No replication) } This solution optimizes for storage since each property is stored once in the system. We use the same design as that for storing the vertex properties. That is, we have one unordered edge property column for each $q_{i,j}$, where $q_{i,j}$ is a structured property of edge label $l_i$. Edges in the system with this solution can be identified as \emph{(edge label, label-level positional offset)}. However, such a design would be oblivious to the fact that edges and their properties are accessed in an order. Reading the edge property value is a random access to these columns. Therefore, the queries cannot benefit from cache locality which would have been there if edge property values were stored together. As a secondary disadvantage, an edge will be stored in 12 bytes (4 byte label, 8 byte offset) in adjacency lists, compared to 8 bytes per edge earlier.

Figure~\ref{fig:sol1} shows the edge property column for edgel label \texttt{FOLLOW}'s \texttt{since} property. Property values are not ordered. For our running example, the forward adjacency list of \texttt{v4} contains edges \texttt{e5}, \texttt{e2} and \texttt{e3}, whose \texttt{since} property value (at positional offsets 3, 4 and 1) in the edge property column is not stored together. 

\vspace{-12pt}

\subparagraph{Solution 2: (Ordered, Replication) } This solution replicates each edge property value twice but offers reading the edge property values sequentially in all scenarios. We keep two \emph{oredered} edge property columns for each $q_{i,j}$, which we call \emph{forward adjacency list-ordered} and \emph{backward adjacency list-ordered}. Property values in forward adjacency list-ordered column are grouped by their edge's source vertex and ordered by source vertex's forward adjacency list. Similary, the property values in the backward adjacency list-ordered column are grouped by the edge's destination vertex and ordered by the destination vertex's backward adjacency list. This way, a query that is reading an adjacency list of a vertex $v$, reads the ajacent edges' property value sequentially from the relevant group of same-ordered edge property column. Reading sequentially from a relevant column ensures maximum cache locality benefits that we can get. This solution also comes with an advantageous side effect. We can completely get rid of storing any edgeID identifier in the adjacency lists; instead, we just store the pointer to the relevant groups of columns with each adjacency list. Then, the location of a property value can be obatined by using the pointer to the relevant group in a column and the positional offset of edge in the adjacency list. Lastly, updates becomes tough as each property value now has to be inserted in 2 columns.

Figure~\ref{fig:sol2} shows the forward and backward adjacency list-ordered edge property columns for edgel label \texttt{FOLLOW}'s \texttt{since} property. For our running example, the forward adjacency list of \texttt{v4} contains edges \texttt{e5}, \texttt{e2} and \texttt{e3}, whose \texttt{since} property appear together in the forward adjacency list-ordered (right) column in the figure. Hence, the properties of the edges in an adjacency list are always sequentially read.

\subsection{Vertex-grouped Edge Property Columns}

Solutions 1 and 2 present extreme cases for optimizing storage and performance, respectively. This solution presents the middle ground. The idea is to avoid replication of property values while not completely losing cache locality benefits that we get from reading values from column sequentially. Hence, we keep any one of the two columns we had for each property $q_{i,j}$ in Solution 2.

We define an \emph{ordered} edge property column, $CE_{i,j}$, for each edge property $q_{i,j}$. The collection of columns having the label $le_{i,j}$ forms a family $FCE_i$ and are either forward or backward adjacency list-ordered. If a family $FCE_i$ is forward adjacency list-ordered, it means that all property values of an edge $e$, having label $le_i$, are grouped by the edge's source vertex and ordered by source vertex's forward adjacency list in columns of $FCE_i$; and similarly if a family for backward adjacency list-ordered column. The property values grouped by source or destination vertex is called a \emph{vertex group} in a column. Property values of $e$ are further located at the same positional offset across all columns of $FCE_i$. Reading from an edge poperty column that is forward adjacency list-oredred is sequential if the edges are read from a vertex's forward adjacency list. However, if the edges are read from the backward adjacency list, the property values has to be accessed randomly out-of-order.

\begin{figure}
	\vspace{-5pt}
	\hfill\includegraphics[scale=0.78]{img/edge-scheme}\hspace*{\fill}
	\caption{Components of the new Edge identification scheme.}
	\label{fig:edge-scheme}
	\vspace{5pt}
\end{figure}

The need for randomly accessing property values means that edge identifier cannot be omitted from storing in adjacency lists. A property of edge $e$ having label $le_i$ can be accessed in a vertex-grouped edge property column by knowing 1) $q_{i,j}$; 2) the vertex on which property values in the column are grouped i.e, either source or destination vertex of $e$); and 3) group-level positional offset of $e$. Owing to issues similar to those faced with using \texttt{vertexID} for fetching vertex properties, we adpot a new scheme for identifying edges in the system. The new scheme identifies an edge by set of folowing components: \textbf{\emph{(edge label, source vertex, destination vertex, group-level positional offset)}}. This scheme gives tremendous opportunity for reducing the memory footprint of storing edges in the adjacency lists, apart from easily accessing edge property columns. We describe storage of edges using new scheme in Section~\ref{sec:storage-optimizations}.

\subsection{Paged Edge Property Columns}
\label{sec:page-level-edge-property-columns}

Vertex-grouped edge property columns is a good solution for storing edge properties but is practically infeasible to maintain in the system. We discuss the limitations of vertex-grouped edge property columns and then propose simple modifications to address those limitations. We call the modified solution, paged edge property group, that removes ordering and groups the property values in a column at a memory page-level instead of vertex-level.

\vspace{-12pt}
\subparagraph{Limitations of Vertex-grouped Edge Property Columns.}
Storing edge properties in vertex-grouped edge property lists are not update friendly owing to the existence of strict ordering in each group of all the columns. For example, assume a scenario where a new edge is has to be inserted at \emph{position 5} in a forward adjacency list $A$ of vertex $V$ having a size \emph{10}. The following sequence of event occurs: 
\begin{enumerate}
	\item All the groups of vertex $v$ that are ordered by the forward adjacency list $A$ of $v$ have to undergo shifting to make space for the properties of the incoming new edge at position 5.
	\item The list-level positional offsets of edges appearing at positions $\geq 5$ in $A$ gets incremented by $1$. 
	\item Changing the positional offsets of the corresponding edges in $A$ is trivial. However, change the postional offset in the other occurance of each edge in the backward adjacency lists of their respective destination vertices is costly since it requires $n$ traversals of adjacency lists, where $n$ is the number of edges whose positional offsets have to be changed.
\end{enumerate}

Apart from costly insertions, maintaining pointers to each of the group in all the columns introduces significant memory overhead. 

\vspace{-16pt}
\subparagraph{Modifications.}
To make insertions easy, we omit the proposition of strict ordering in each group of the columns. By giving up ordering, queries no longer read the edge property values sequentially while extending from the adjacency list on which the group is ordered. However, we still maintain cache locality which keeps the number of cache misses while reading property values in our solution to be significantly closer to that when property values are ordered.

We map $n$ ordered vertex groups in a vertex-grouped edge property columns into one unordered page in paged edge property column. This way, a single page holds the property values from $n$ vertex groups. The mapping between vertex groups and page of respective columns is straightforward. Vertex groups of vertices having label-level positional offset $p$ maps to the $p/n$th page in the column. The main benefit of the paged edge property column comes from the fact that it is unordered. Hence, new edge insertions becomes easy as they get appended into relevant paged edge property column similar to how insertions happen in vertex property columns~\ref{sec:vertex-property-columns}. Property values in a page are still referenced by the group-level postional offset in the new edge identification scheme. However, group-level positional offset in paged edge property column no longer refers to the position of an edge in the ordering adjacency list. Now, the group-level positional offset only refers to the position of properties of edge in paged edge property columns of a family. 

The driving goal is to choose $n$ such that property values of edges in a defining adjacency list are not too sparse for a cache miss to occur with \emph{each} access of a value. Hence, the value of $n$ is heavily dependant in a number of features like the cache line size, column element width and the average number of edges in the adjacency lists in system. We choose the value of n in range $32, 512$. We show in experiments that our solution is not significantly worse than the vertex-grouped edge property column when performing sequential reads. Comparing the two, we get a minimal overhead of 1.2x on read intensive workloads. However, with completely unordered edge property column, the overhead over vertex-grouped edge property columns is as high as 4.5x.

\section{Adjacency Lists as a Column store}
\label{sec:adjacency-lists}


\section{Storage optimizations}
\label{sec:storage-optimizations}

In this section, we present ideas on how our storage benefits (in terms of reducing the memory footprint) from the new identification schemes and structures that the data-structures introduced in previous sections. Our optimizations are critical in achieving high-levels of compactions while storing edges in the adjacency lists, thereby reducing the overall memory footprint of data in the system.

\subsection{Removing unnecessary edge information.}

The new edge identification scheme is \emph{virtual}. We do not need to store all the 4 components of the new edge identifier. While iterating on an adjacency list, the edge label of adjacent edge $e$ and the extending vertex ($e$'s source vertex in forward adjacency list and it's destination vertex in backward adjacency list) are already known and hence are not stored in the list. The neighbouring vertex ($e$'s destination vertex in forward adjacency list and source vertex in backward adjacency list) identifier is stored from prior. Therefore, the only storage overhead is the group-level positional offset. The offset is often not more than 1 or 2 bytes. This follows from the fact that the number of edges in most of the adjacency list is very small (by the power-law). Hence, storing the group-level positional offsets as a variable-width element saves memory by 2-3x. Moreover, in many cases, even group-level positional offsets can be omitted from storing in adjacency lists. We look at these cases in \ref{sec:storage-optimizations}.

At the time we introduced the new edge identification scheme in \ref{sec:edge-property-columns}, we briefly discussed the size of storing each edge in the adjacency lists. Out of 4 components in the new edge identifier, only 2 components, \emph{(neighbouring vertex, page-level positional offset)}, are needed to be stored per edge in the adjacency list. Note that the neighbouring vertex itself comprises of 2 components: \emph{(vertex type, type-level positional offset)}. Given that the vertex identifier is 12 bytes and page-level positional offset can be stored in 1 or 2 bytes, storing an edge in an adjacency list takes 14 bytes. We can omit to store the few components of the edge in the following cases: 

\begin{itemize}
	\item \textbf{Neighbouring vertex's type can be omitted while storing edges if it can be inferred implicitly.} We know by \ref{ssec:graph-schema}, that an edge label $l$ has a fixed set of source vertex types and destination vertex types. Using this, we can infer the \emph{probable set} of neighbouring vertex types, $T_N$, while extending a vertex. $T_N$ is defined as the set of vertex types whose vertices an extending vertex can extend to.

	Note that during the \texttt{E/I} operation, we already know, 1) the extending vertex, 2) \emph{direction} of extend, and 3) the edge label of edge we want to extend to. $T_N$ can be determined from the edge label and the direction of extend. If direction of extend is forward, $T_N$ is the destination vertex types of the edge label. Similarly, if direction is backward, source vertex types of the edge label forms $T_N$. 
	
	For cases when $|T_N|$ is $1$, the neighbouring vertex type in our extend operation is fixed. In these case, there is no need to store the neighbouring vertex types with \emph{all} the edges in adjacency list - and can be determined from the graph's schema. The following rules assist the omission of neighbour vertex types while storing edges:
	
	\begin{itemize}
		\item If edge label $l$ has only a source vertex type, then an edge $e$, from vertex $u$ to $v$ and having label $l$, can be stored without the neighbour vertex type in the backward adjacency lists of $v$.
		
		\item Similarly, if edge label $l$ has only a destination vertex type, then an edge $e$, from vertex $u$ to $v$ and having label $l$, can be stored without the neighbour vertex type in the forward adjacency lists of $u$.
	\end{itemize}

    \item \textbf{Edges that do not have properties, do not need page-level positional offsets.} From section \ref{sec:edge-property-columns} and \ref{sec:page-level-edge-property-columns}, we know that an edge's positional offsets is required \emph{only} while accessing its properties' value from relevant page-level edge property columns. Hence, in the absence of any properties on an edge, the (page-level) positional offset of that edge is undefined. Such edges are stored in the adjacency lists without any positional offsets information. In the absense of page-level positional offset, an edge cannot be identified globally since there can be multiple edge with unique \emph{(edge label, source vertex, destination vertex)} tuple. We reason that there is no requirement for an edge to be \emph{identifiable} in the system if not for accessing its properties. Conventionally, the purpose an  \texttt{edgeID} has been two-fold, 1) to connect source and destination vertices and, 2) to reference edge properties (if present). We are able to still fulfill 1) by not having a page-level positional offset while 2) stands void in the absence of properties. 
	
\end{itemize}

\subsection{Fixed-length null suppression}

The components of an edge identifier, usually, do not occupy the entire-width allocated to them in storage. For instance, a neighbouring vertex type is stored as a fixed 4-byte value in the adjacency lists. Likewise, neighbouring vertices' type-level positional offsets do not often exhaust the whole of 8 bytes allocated to them in storage. Clearly 


\subsection{Vertex property columns for single cardinality labels.}

Single cardinality labels are edge labels that have one of the following cardinalities, 1) 1..1 (one-to-one), 2) 1..n (one-to-many), and 3) n..1 (many-to-one). Such labels guarantee that there will be at most a single edge from the source vertex or to the destination vertex. For instance, let us consider an edge label BIRTHDAY that connects a vertex of type PERSON to the vertex of type DATE. Cardinality of BIRTHDAY is \emph{many-to-one}. That is, a vertex PERSON is connected to only one vertex of type DATE, while a vertex DATE can have connections to multiple PERSONs through the edge of label BIRTHDAY.

Single cardinality labels provide the opportunity of optimizing how the edges of such labels are stored. We use the fact that an edge $e$ of a single cardinality label is the \emph{only} element in either the forward adjacency list of $e$'s source vertex or forward adjacency list of $e$'s destination vertex or both. 

...

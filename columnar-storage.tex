\chapter{Columnar Storage}
\label{c:columnar-storage}

In this chapter, we explore the application of columnar data structures for different storage components of  \gls{gdbms}s, to meet the desiderata we outlined in Chapter~\ref{c:guidelines}. Section \ref{sec:vertex-property-columns} describes the design of columns to store vertex properties and a new compact vertex identification scheme that accompanies the design. In Section \ref{sec:edge-property-columns}, we start by describing two columnar storage designs to store edge properties and their pros and cons. Then, we propose a third design, \textcolor{red}{paged edge property list}, that is a sweet spot between the earlier two designs and the one we adopt for storing edge properties. Similar to Section~\ref{sec:vertex-property-columns}, we describe a novel and compact edge identification scheme that accompanies our design from edge property columns. In Section~\ref{sec:single-cardinality-cols}, we describe a storage optimization that involves storing edges with multiplicities 1-1, 1-n, n-1 in columns instead of using the CSR structure. Section~\ref{sec:storage-optimizations} describes several storage optimizations to the adjacency lists to reduce the system's memory footprint without sacrificing query performance, using different types of structure that may exist in input graphs that we observed in Guideline~\ref{gdln:graph-schema}.

\section{Columnar Storage for Vertex Properties}
\label{sec:vertex-property-columns}

\begin{figure}
	\hfill\includegraphics[scale=0.85]{img/vpcols}\hspace*{\fill}
	\caption{Vertex property columns for the graph in Figure~\ref{fig:runn}.}
	\label{fig:vpcols}
\end{figure}

Columnar data-structures can be directly used for storing vertex properties. Let $(l_1, l_2, ...)$ be the vertex labels in a graph. Let $p_{i,1},  p_{i,2}, ... p_{i, n}$ be the structured vertex properties of $l_i$, each with a specific datatype $d_{i,j}$. We define a \emph{vertex property column} for each $p_{i,j}$, having a fixed data type $d_{i,j}$. Each column stores the value of a single property $p_{i,j}$ for all vertices having label $l_i$, at consecutive locations. All property values of a particular vertex $v$ with label $l_i$ is located at the same positional offset for each column for $p_{i,j}$. 

% reading a property.

Ideally, the property value of a vertex should directly be read using the ID of the vertex as the positional offset in the column. However, \gls{gdbms} typically gives globally unique 8-byte consecutive IDs to all the vertices in the system, irrespective of their labels. That means ID 0 can be given to a vertex with label PERSON and 1 to a vertex with label ORG and 2 to another vertex PERSON etc. We cannot use this ID scheme as the positional offset for the above design. One possible solution is to maintain a map for each label, from each vertex $v$'s \enquote{global} ID to a \enquote{local} label-level positional offset, which is unique only among all vertices with the same label as $v$. This requires extra storage for maintaining the map and one level of indirection when accessing the vertex properties. Instead, we adopted an ID scheme where each vertex is identified by a \emph{\textbf{(vertex label, label-level positional offset)}} tuple in the system in place of global vertex ID. This allows direct access to the properties by using the label-level positional offset which now is part of the vertex ID. However, using this new vertex ID scheme requires materializing 2 pieces of information in the adjacency lists - a vertex label and a positional offset, compared with a single global vertex ID. This may increase the memory overhead if the local positional offsets and the global vertex ID are of the same size. However, we will show in Section \ref{sec:storage-optimizations} that we can often avoid storing the vertex labels with vertex IDs and even save space by using fewer bytes for local positional offsets than the bytes needed by the global vertex IDs.

For reference, Figure~\ref{fig:vpcols} shows a set of vertex property columns for our example graph in Figure~\ref{fig:runn}. It has 2 set of columns one for each vertex label, with a column for each structured property of the label. The global vertex IDs on the right of the set of columns of a vertex label indicates the positional offset at which the properties of a particular vertex are located in the columns of a family. For instance, the properties of vertex $v2$ appear at offset $1$ in columns of PERSON's family. By the new vertex ID scheme, $v2$ is identified as \texttt{PRESON:1}. 

% updates.

Recall from Guideline~\ref{gdln:vertices-unordered} that in general, reading the properties of vertices (specifically when reading the properties of neighbors of a vertex) cannot be localized without prohibitive replication. In light of this guideline, we adopt a simple and efficient additions and deletion scheme for of vertex properties and vertices. Deleting  the property of vertex $v$ is handled by setting the property at $v$'s positional offset to NULL.  Deleting $v$ is handled by setting all of $v$'s properties to NULL and adding $v$'s positional offset to a list of ``recycled'' offsets. When a new vertex $v$ is added, the system generates an ID by using a recycled offset if one exists or gives a new consecutive positional offset (i.e., increments the maximum positional offset by 1). Updating $v$'s property is handled by overwriting the value in the property column for $v$'s positional offset. All of these operations are very efficient involving only random access to different locations in columns.

\section{Columnar Storage for Edge Properties}
\label{sec:edge-property-columns}

Recall from Guideline~\ref{ssec:edges-ordered} that edges and edge properties  are read by the \texttt{JOIN} operators in the order they appear in the adjacency lists. \gls{gdbms}s store the edges, i.e the (edge ID, neighbour  vertex ID) pairs, consecutively in adjacency lists, through double indexing. Ideally, edge properties should also be stored in the same order. In this section, we begin by presenting two columnar storage designs for storing edge properties which can be seen as opposite ends of a design spectrum. The first design, {\em edge property columns}, is optimized for \emph{storage} and does not replicate the edge properties. The second design, {\em double-indexed property lists}, is optimized for \emph{performance} through double indexing of the edge properties. We then describe a third design, {\em single-directional property lists}, that can be seen as a sweet spot between the previous two designs, which localizes the reads in one direction without any replication. However, this natural third design has several limitations, which we address in our fourth design, {\em single-directional property pages}, which is adopted in Graphflow. 

% However, this also requires double indexing, which is expensive as each property needs to be replicated. 
\begin{figure}
	\hspace*{-20pt}
	\begin{subfigure}{0.45\textwidth}
		\vspace{14pt}
		\centering
		\includegraphics[scale=0.75]{img/sol1}
		\captionsetup{justification=centering}
		\vspace{12pt}
		\caption{Edge Property Columns}
		\label{fig:sol1}
	\end{subfigure}
	\begin{subfigure}{0.55\textwidth}
		\centering
		\includegraphics[scale=0.75]{img/sol2}
		\captionsetup{justification=centering}
		\caption{Double-indexed Property Lists}
		\label{fig:sol2}
	\end{subfigure}
	\captionsetup{justification=centering}
	\caption{Storing edge properties of FOLLOWS edges in the Edge Property Columns and Double-indexed Property Lists.}
	\label{fig:sol1and2}
\end{figure}

\subsection{Edge Property Columns and Double-Indexed Property Lists}

\noindent {\bf Edge Property Columns (Nonsequential reads, no replication):} One possibility is to use the columnar storage design similar to that for storing the vertex properties. That is, we have one edge property column for each $q_{i,j}$, where $q_{i,j}$ is a structured property of edge label $l_i$. Edges in the system with this solution can be identified as \emph{(edge label, label-level positional offset)}. However, such a design would not localize the properties of the edge according to their appearance in the adjacency lists, so cannot provide sequential reads when reading the edge properties. Figure~\ref{fig:sol1} shows how this particular design would look like. The figure shows a column storing property \texttt{since} of FOLLOWS edges. The property values are not ordered. For our example, the forward adjacency list of \texttt{v4} contains edges \texttt{e5}, \texttt{e2} and \texttt{e3}, whose \texttt{since} property values (at positional offsets 3, 4 and 1) are not stored consecutively in the edge property column. 

\noindent {\bf Double-Indexed Property Lists (Sequential reads in both directions, 2x replication):} An alternative solution is to directly mimic the storage of the adjacency lists for storing the edge properties. For each vertex $v$ that has edges with a label $l_i$, and each $q_{i,j}$, we store the edge properties in the \emph{forward property lists} and \emph{backward property lists}. This provides sequential read of properties. For example, a query that is reading the forward (backward) adjacency list of $v$ can read the edge property values of the edges sequentially from the forward (backward) adjacency property list of $v$. Figure~\ref{fig:sol2} shows the forward and backward property lists for edgel label \texttt{FOLLOWS} in our example graph in Figure~\ref{fig:runn}. However, this design requires replicating each edge property twice. In addition, if the original adjacency lists are sorted, then all the property lists need to be sorted too in the same way, which would make updates slower. 

\subsection{Single-directional Property Pages}

\begin{figure}
	\hfill\includegraphics[scale=0.78]{img/single-dir-prop-list}\hspace*{\fill}
	\captionsetup{justification=centering}
	\caption{Single-directional Adjacency Property Lists}
	\label{fig:single-dir-prop-list}
\end{figure}

A natural middle ground between edge property columns and double-indexed property lists is to store only one of the forward or the backward property lists. We call this design \emph{single-directional adjacency property lists}. Suppose the system indexes the properties of the edges with label $l_i$ in the forward direction. Then, the edge properties can be read sequentially in the forward direction. However when reading the edges of a vertex $v$ in the backward direction, then the edge properties will not be sequential. Figure~\ref{fig:single-dir-prop-list} shows the Single-directional Adjacency Property Lists for storing the properties of the example graph in Figure~\ref{fig:runn}. In the example, edge properties in the family of FOLLOW and WORKAT labels are stored in the forward adjacency property lists, while in STUDYAT the properties are in the backward adjacency property lists. In this design, reading the edges in the backward direction requires that given the ID of an edge $e$, the system is able to locate the positional offset of $e$ in the forward direction. This requires a new edge ID scheme. Specifically, the conventional globally consecutive edge IDs cannot be used to access the properties quickly as they do not contain information about positional offsets. We next describe a new edge ID scheme to achieve this. Then we talk about some important limitations of single-directional property lists, which we address in a new design.

To access a property of an edge $e$ having label $le_i$, we need 3 pieces of information; 1) $q_{i,j}$; 2) source vertex if the $q_{i,j}$'s values are stored in the forward adjacency property lists, else destination vertex; and 3) the list-level positional offset of $e$ in that property list. For instance, in figure~\ref{fig:single-dir-prop-list}, \texttt{since} property of $e2$ can be accessed knowing $v4$ (source vertex of $e2$) and offset of $e2$ in $v4$'s forward adjacency property list, i.e 1. We adopt a new edge identification scheme that identifies the edge in the system by a tuple having 4 components: \textbf{\emph{(edge label, source vertex, destination vertex, list-level positional offset)}}. In our new scheme, the $e2$'s ID will be given as \texttt{FOLLOWS:v4:v1:2}, where $v4$ and $v1$ are the source and destination edges of $e2$. These edge IDs provides us with compact storage too. Most of the components need not be stored in the adjacency lists and the edge ID can be constructed during query execution by reading as few as only the neighbour vertex's local positional offset in the property list. 

\begin{figure}
	\hfill\includegraphics[scale=0.78]{img/edge-scheme}\hspace*{\fill}
	\captionsetup{justification=centering}
	\caption{Components of the new edge identification scheme. \todo{change group-level to list-level.}}
	\label{fig:edge-scheme}
\end{figure}

\noindent {\bf Limitation of single-directional property lists:} Though single-directional adjacency property lists are a good middle-ground solution, it has an important limitation. Suppose that the property list for property $q_{i,j}$ of edge label $le_i$ is indexed in the forward direction. If the original adjacency lists are sorted,  any insertion or deletion can change a large number of, possibly all of the positional offsets of every edge in the adjacency list. Suppose an edge is inserted to the beginning of $v$'s forward adjacency list $L_f$. This requires first calculating a map of old and new positional offsets of the edges in $L_f$, then searching through each backward neighbor of $v$ and finding each edge in the backward adjacency list and updating its positional offset. A similar problem exists when an edge is deleted. If the original edges are not sorted, then insertions can be handled easily but handling deletions is challenging. The system has two options for deletions. First, the system can directly delete the edge $e$, which again can change the positional offsets of as many as $|L_f|$ edges. Instead, the system can thumbnail $e$'s positional offset and recycled $e$'s positional offset as was described for vertex deletions. However, this is also expensive. In contrast to keeping a single list of recycled IDs as in vertex property columns, the system now needs to keep track of recycled positional offsets for each vertex, so up to $|V|$ many recycled IDs list.

\noindent {\bf Single-directional property pages:} To address the above limitation, we take $k$ property lists (by default 64) and store their properties in a property page. Properties in a property page is not necessarily stored consecutively. However, because we use a small value of $k$ and adjacency lists of many vertices are short in many real world datasets, these properties are stored in close-by memory locations. We do not sort these pages when the original adjacency lists are sorted and keep a recycled ID list for each page, avoiding the cost of sorting and the maintenance of list-level recycled ID lists. We can use the same edge ID scheme we described above, except the positional offsets now identify the properties of edges in property pages, instead of property lists. Suppose again that the property $q_{i, j}$ is stored in the forward direction (though properties of $k$ lists are grouped). Given an edge $e$ in the scheme from Figure~\ref{fig:edge-scheme}, we can take the source vertex's label-level positional offset and divide it by $k$ to identify the page in which $e$'s $q_{i, j}$ property is. Within this page, the property can be accessed with a single lookup using the positional offset of $e$.

%The mapping from a property list to its corresponding page is straightforward. Single-directional adjacency property list for vertex $v$ and property $q_{i,j}$ maps to the $i$th page for property $q_{i,j}$, where $i$ is mod $n$ of $v$'s local positional offset. The benefit of using pages comes from it being unordered. This makes new edge insertions easy as now, the new edge properties get appended into their respective pages or recycle the location of an already deleted edge, similar to how insertions happen in vertex property columns. 

\begin{figure}
	\hfill\includegraphics[scale=0.78]{img/paged}\hspace*{\fill}
	\captionsetup{justification=centering}
	\caption{Mapping single-directional adjacency property lists to single-directional adjacency property pages for since property in Figure~\ref{fig:runn}.$n=2$.}
	\label{fig:paged}
\end{figure}

Figure~\ref{fig:paged} shows the mapping of a single-directional adjacency property lists to single-directional  property pages for $n=2$. The paged edge property column has two pages that stores the property values from vertex groups $(v1,v2)$ and $(v3,v4)$ respectively, assuming that the local positional offset of $vi$ is $i$ and $pi$ is the $i$th property page for \texttt{since} property. 
%The value of $n$ is chosen such that edges' property values are not too far apart from each as they were stored in %the property lists. This reduces the cache miss to occur with \emph{each} access of a value in a page. Hence, the value of $n$ is dependant on 3 factors: 1) the cache line size; 2) width of an element in the page, and 3) the average number of edges in the adjacency lists. Ideally, the value of n is optimum in the range $[32, 512]$. 
We show in evaluation that single-directional  property pages is similar, about 1.2x slower, in performance to single-directional property lists in read-heavy stress tests and about 4.5x faster than using edge property columns.

\section{Columns for 1-1, 1-n, n-1 Edge Labels}
\label{sec:single-cardinality-cols}

The 1-1, 1-n, n-1 edge label cardinality edge labels guarantee that there will be at most a single edge from the source vertex or to the destination vertex. We call these \emph{single cardinality edge labels}. In particular, a vertex that can have outward or inward edges of label $le_i$, where cardinality of $le_i$ is \texttt{1-1}, is assured to have only a single edge of that label. However, if the cardinality of $le_i$ is either \texttt{n-1} or \texttt{1-n}, then only source or only destination vertex respectively, is assured to have a single edge of $le_i$. For instance, in our Figure~\ref{fig:runn} example graph, edge label STUDYAT and WORKAT have the cardinality \texttt{n-1}. This means that PERSON vertices can have at most one STUDYAT's and WORKAT's edge. The size of such a vertex's adjacency list of single cardinality edge label is fixed to 1. Hence, instead of storing the single edge in these adjacency lists in the last level of the 2-level CSR structure, we can directly access the single edge as a \emph{property} of either the source of destination vertex. Specifically, \texttt{1-1} edge label edge can be stored as a property of either the source vertex or the destination vertex, whereas \texttt{n-1} and \texttt{1-n} label edges has to be stored as the property of source and destination vertex respectively. 

Benefits of storing edges as special vertex properties is two-fold, 1) there is no need to maintain pointers to the edges in the last level of CSR structure, and 2) since there are no pinters, an indirection is saved while reading these edges. Figure~\ref{fig:single-cardinality-cols} shows the STUDY AT edges stored as the special properties of PERSON vertices. Moreover, the properties of such an edge $e$ can also be stored in structures similar to the vertex property columns, instead of single-directiional property pages. These properties are hence, accessed by vertex $v$'s local positional offset, instead of page-level positional offset, where $v$ is the vertex whose special property the edge is. Thus, we do not need page-level positional offsets for the edges of single cardinality edge labels.

\begin{figure}
	\hfill\includegraphics[scale=0.78]{img/single-cardinality-cols}\hspace*{\fill}
	\captionsetup{justification=centering}
	\caption{Storage of edges having single cardinality edge label STUDYAT and WORKAT as special property of PERSON.}
	\label{fig:single-cardinality-cols}
\end{figure}

Figure~\ref{fig:single-cardinality-cols} shows the edges of edge label STUDYAT and WORKAT, from our example graph, and their properties being stored as the special property of vertex type PERSON. 

\section{Storing Edges and Vertices in Adjacency Lists}
\label{sec:storage-optimizations}

In this section, we show how vertices and edges can be stored compactly in the adjacency lists using the new identification schemes that we introduced in Sections \ref{sec:vertex-property-columns} and \ref{sec:edge-property-columns}. In particular, decomposing the ID into multiple small components enables us to either avoid storing components which are unnecessary or can be inferred, or store it in a compressed fashion using one of the compression techniques we describe in Chapter~\ref{columnar-compression}.

The new edge identification scheme recognizes an edge with 4 components: 1) edge label, 2) source vertex, 3) destination vertex and 4) local positional offset in the property pages of its properties. However, while storing the edge in an adjacency list, the edge label, source and destination vertex components can be omitted. For instance, while storing an edge $e(u,v)$ having edge label $le_i$ in the $u$'s adjacency list of $le_i$ edges, we store projection of $e$'s ID with $le_i$ and $u$ factored out. $v$ is not stored either since the neighbour vertex is stored beside each edge by default. Finally, the positional offset can be stored cheaply as often they are not more than 1 or 2 bytes hence. This follows from the fact that the number of edges in most of the adjacency list is relatively small (by the power-law) and so are the number of elements in each page. 

To sum up, each entry in the adjacency list stores a small (1-2 byte) positional offset and the neighbour vertex ID which itself comprises of vertex label and local positional offset. We now present some common scenarios that allow for even further compaction by choosing to omit to store certain components:

\begin{itemize}
	\item \textbf{When the edge label can determine the neighbour vertex label.} We know from Guideline~\ref{gdln:graph-schema} that the edge labels can determine the source or destination vertex labels whose vertices can have that label's edge. Using this information, we can determine the neighbour vertex labels in an adjacency list with edges of a single edge label. For instance, our example graph in Figure~\ref{fig:runn} contains edges having label FOLLOWS only between vertices having label PERSON. Hence, joining from any of PERSON vertex's forward (or backward) adjacency lists with edges having label FOLLOWS, we can be inferred that all the neighbour vertices in the adjacency list have label PERSON. For cases when the edge label has only a single neighbour vertex label, explicitly storing the same neighbour vertex label with each edge in the adjacency list can be avoided. This limits this optimization only to the case when the cardinality of source or destination vertex labels set of an edge label is 1. Still, the optimization holds much relevance since edge labels in the graph data are mostly defined between a single source and destination vertex label. 
	
	\item \textbf{When the edge label does not have properties.} In the absence of any properties on edges having label $le_i$, i.e, the set of structured properties determined by $le_i$ is empty, the page-level positional offset of $le_i$ edges is undefined. We can store such edges in the adjacency list without their positional offsets. With page-level positional offset undefined, an edge cannot be identified globally since there can be multiple edges with unique \emph{(edge label, source vertex, destination vertex)} tuple. We reason that there is no need for an edge to be \emph{identifiable} in the system if not for accessing its properties. Conventionally, the purpose an  \texttt{edgeID} has been two-fold, 1) to connect the source and destination vertices and, 2) to reference edge properties (if present). We can still fulfil 1) while 2) stands void in the current scenario. 
	
	\item \textbf{When the edge label has cardinality 1-1, 1-n, n-1.} As mentioned in Section~\ref{sec:cols-for-single-cardinality}, we do not need positional offsets for accessing edge properties of edges having label cardinality 1-1, 1-n, n-1, which can be done directly using the positional offset of either the source or destination vertex. Hence, we need page-level positional offsets in the edge ID only of the cardinality of edge's label is \texttt{n-n} and it has structures properties.
	
\end{itemize}

Using the new identification scheme and further applying the above-mentioned optimizations, the adjacent edges and neighbour vertices in adjacency lists by as less as a single piece of information. We can still further reduce the memory footprint of adjacency lists by applying compression on components of the edge that has to be stored after removing unnecessary ones. We use \emph{fixed-bitwidth NULL compression}, which we describe in Section~\ref{sec:col-existing}, to compress the components of edge in the adjacency lists. Using this technique, a particular component of each edge in an adjacency list is encoded as fixed-width elements by removing a common number of leading zero bytes (that will be determimined by the maximum element) from each of them. For example, if an adjacency list has edge $[e1, e2, e3, e4, e5]$ with the neighbour vertex labels $[1, 2, 1, 1, 2]$, then the neighbour vertex label is encoded in 1 byte in the adjacency list, instead of usual 4-byte INT. Similarly, if the same set of edges have neighbour's local positional offsets $[1000, 2000, 3000, 2, 1]$, then each offset is stored in 2 bytes in the adjacency list.

We show the decrease in memory footprint of the adjacency lists, with each optimization, over the LDB SnB dataset, with more than 1 billion edges, in Chapter~\ref{c:evaluation}. Our evaluations reveal that the new scheme with opportunities to perform immense compaction and compression can reduce the size of adjacency lists by upto 94x, storing barely over 6 bytes of data per indexed edge in the system.


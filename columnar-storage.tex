\chapter{Columnar Storage}
\label{c:columnar-storage}

In this chapter, we explore the application of columnar data structures for different storage components of the \gls{gdbms}, to meet the desiderata we outlined in Chapter~\ref{c:guidelines}. Section \ref{sec:vertex-property-columns} describes the design of columns to store vertex properties and a new compact vertex identification scheme that accompanies the design. In Section \ref{sec:edge-property-columns}, we start by describing the two columnar storage designs to store edge properties and their pros and cons. Then, we propose a third design, \textcolor{red}{paged edge property list}, that is a sweet spot between the earlier two designs and the one we adopt as an optimum design for storing edge properties. Similar to Section~\ref{sec:vertex-property-columns}, we describe a novel and compact edge identification scheme that accompanies our design from edge property columns. \textcolor{red}{As we observed earlier, adjacency lists are already columnar structures.} Section~\ref{sec:adjacency-lists} describes several storage optimizations to the adjacency lists to reduce the system's memory footprint without sacrificing query performance, using the type of structures we observed in guideline~\ref{gdln:graph-schema}.

\section{Columns for Vertex Properties}
\label{sec:vertex-property-columns}

\begin{figure}
	\vspace{-25pt}
	\hfill\includegraphics[scale=0.85]{img/vpcols}\hspace*{\fill}
	\caption{Vertex property columns for the graph in Figure~\ref{fig:runn}.}
	\label{fig:vpcols}
	\vspace{-8pt}
\end{figure}

Columnar data-structures can be directly used for storing vertex properties. Let $(lv_1, lv_2, ...)$ be the vertex labels in a graph. Let $p_{i,1},  p_{i,2}, ... p_{i, n}$ be the structured vertex properties of $lv_i$, with a datatype $d_{i,j}$. We define a \emph{vertex property column} for each $p_{i,j}$, having a fixed data type $d_{i,j}$. Each column stores the value of a single property $p_{i,j}$ for all vertices having $lv_i$ at consecutive locations. We call the collection of columns of all properties of a particular vertex label $lv_i$, the \emph{vertex property column family} of $lv_i$. All property values of a particular vertex $v$, with label $lv_i$, is located at the same positional offset in their respective columns in column family of  $lv_i$. We call this positional offset, \emph{(vertex) label-level positional offset} of vertex $v$.

% reading a property.

Ideally, the property value of a vertex should directly be read using the ID of the vertex as the positional offset in the column. However, \gls{gdbms} typically gives globally unique 8-byte consecutive IDs to all the vertices in the system, irrespective of their labels. That means ID 0 can be given to a vertex with label PRESION and 1 to the vertex with label ORG. We cannot use this ID scheme as the positional offset for the above design. One possible solution is to maintain a map for each label, from the vertex's \enquote{global} ID to its \enquote{local}, i.e, a label-level positional offset of a vertex in the column. This, however, requires extra storage for maintaining the map and one level of indirection when accessing the vertex properties. Instead, we identify a vertex by a \emph{\textbf{(vertex label, label-level positional offset)}} tuple in the system in place of global vertex ID. This allows direct access to the properties by using the positional offset which now is part of the vertex ID. However, using this new vertex ID scheme requires materializing 2 pieces of information in the adjacency lists - a vertex label and a local positional offset, compared to only global vertex ID by the earlier scheme. This increases the memory overhead as the \enquote{local} positional offsets and the global vertex ID are of the same size. However, as we will show in section \ref{sec:storage-optimizations}, we can often avoid storing the vertex labels with vertex IDs and even save space by using fewer bytes for local positional offsets than the bytes needed by the global vertex IDs.

For reference, figure~\ref{fig:vpcols} shows set of vertex property columns for our example graph in figure~\ref{fig:runn}. It has 2 column families, one for each vertex label, with a column for each structured property of the label. The global vertex IDs on the right of a column family indicates the positional offset at which the properties of a particular vertex are located in the columns of a family. For instance, the properties of vertex $v2$ appear at offset $1$ in columns of PERSON's family. By the new vertex ID scheme, $v2$ is identified as \texttt{PRESON:1}. 

% updates.

The design of the vertex property columns allows for easy insertions and deletions of the vertex properties. Since we cannot localize vertex reads by ordering the properties (Guideline~\ref{gdln:vertices-unordered}), the vertex property columns are unordered. This makes insertions easy which are done by either appending the vertex properties to the appropriate column family and assigning a new vertex ID, or reusing the ID of a previously deleted vertex with the same label. Deleting a property from a column is simply overwriting the property value by a \texttt{NULL} symbol while deleting a vertex involves removing all the edges to/from that vertex from adjacency lists and the ID is recycled. 

\section{Columns for Edge properties}
\label{sec:edge-property-columns}

Recall from Guideline~\ref{ssec:edges-ordered} that edges and edge properties  are read by the \texttt{JOIN} operators in the order they appear in the adjacency lists. We know that the \gls{gdbms} already stores the edges, i.e the edge ID and the neighbour vertex ID, consecutively in the adjacecy lists. Ideally, edge properties should also be stored in the same order. However, as we discuss in this section, this is not possible without replication. We begin by presesnting two columns storage designs for storing edge properties which can be seen as opposite ends of a design spectrum, optimizing the system for \emph{storage} and \emph{performance} respectively:

\begin{figure}
	\vspace{-30pt}
	\hspace*{-20pt}
	\begin{subfigure}{0.45\textwidth}
		\vspace{20pt}
		\centering
		\includegraphics[scale=0.75]{img/sol1}
		\captionsetup{justification=centering}
		\vspace{10pt}
		\caption{Sol 1: (Unordered, No Replication)}
		\label{fig:sol1}
	\end{subfigure}
	\begin{subfigure}{0.55\textwidth}
		\centering
		\includegraphics[scale=0.75]{img/sol2}
		\captionsetup{justification=centering}
		\caption{Sol 2: (Ordered, Replication)}
		\label{fig:sol2}
	\end{subfigure}
	\captionsetup{justification=centering}
	\vspace{5pt}
	\caption{Edge property columns in Solution 1 and 2 for \texttt{since} property in Figure~\ref{fig:runn}.}
	\vspace{-10pt}
	\label{fig:sol1and2}
\end{figure}

\vspace{-12pt}
\subparagraph{Solution 1: (Unordered, No replication)}One possibility is to use the columnar storage design similar to that for storing the vertex properties. That is, we have one edge property column for each $q_{i,j}$, where $q_{i,j}$ is a structured property of edge label $l_i$. Edges in the system with this solution can be identified as \emph{(edge label, label-level positional offset)}. However, such a design would not localize the properties of the edge according to their appearance in the adjacency lists, so cannot provide sequential reads when reading the edge properties. Figure~\ref{fig:sol1} shows how this particular design would look like. The figure shows a column with property values for property \texttt{since} for FOLLOWS edges. The property values are not ordered. For our example, the forward adjacency list of \texttt{v4} contains edges \texttt{e5}, \texttt{e2} and \texttt{e3}, whose \texttt{since} property values (at positional offsets 3, 4 and 1) are not stored together in the edge property column. 

\vspace{-12pt}

\subparagraph{Solution 2: (Ordered, Replication)}An alternative solution is to directly mimic the storage of the adjacency lists for storing the edge properties. Specifically, let the structured edge properties of an edge label $le_i$ be $q_{i,1}, q_{i,2} ... q_{i,n}$. For each vertex $v$ that has edges with a label $le_i$, and each $q_{i,j}$, we store the edge properties in the \emph{forward adjacency property lists} and \emph{backward adjacency property lists}. However, this design requires replicating each edge property twice. In addition, if the original adjacency lists are sorted, then all the property lists need to be sorted too in the same way, which would make updates slower (though this may be acceptable, given that \gls{gdbms}s are primarily read optimized systems) \textcolor{red}{i think we shouldnt mention this, since this is the limitation of next scheme}. Storing the edge properties replicated in two property lists provides sequential read of properties. A query that is reading the forward (backward) adjacency list of $v$ can read the edge property values of the edges sequentially from the forward (backward) adjacency property list of $v$. Figure~\ref{fig:sol2} shows the forward and backward adjacency property lists for \texttt{since} property of edgel label \texttt{FOLLOW} in our example graph in Figure~\ref{fig:runn}.

\subsection{Single-directional Adjacency Property List Page}

We presented two solutions for storing edge properties in a columnar data-structure, one optimized for storage and other for performance. We now present the third solution, that is the sweet spot between the two solutions, i.e, we avoid replication of the edge properties without completely sacrificing the benefits from localizing them. In particular, for each edge label $le_i$, we store the properties of edges with label $le_i$ either in the forward or backward adjacency property lists. This way, the edge properties can still be read sequentially when edges are read from any one of the adjacency lists.  Specifically, if a query reads edges having $le_i$ from the forward adjacency list of a vertex and the properties of $le_i$ edges are stored in the forward adjacency property lists, then the edge properties can be sequentially read. While reading edges from the other adjacency lists, the edge properties has to be accessed randomly.

\begin{figure}
	\vspace{-25pt}
	\hfill\includegraphics[scale=0.78]{img/single-dir-prop-list}\hspace*{\fill}
	\captionsetup{justification=centering}
	\caption{Single-directional Adjacency Property Lists}
	\label{fig:single-dir-prop-list}
	\vspace{0pt}
\end{figure}

Figure~\ref{fig:single-dir-prop-list} shows the Single-directional Adjacency Property Lists for storing the properties of the example graph in Figure~\ref{fig:runn}. There are 3 families, one for each edge label. Edge properties in the family of FOLLOW and WORKAT labels are stored in the forward adjacency property lists, while in STUDYAT the properties are in the backward adjacency property lists.

To access a property of an edge $e$ having label $le_i$, we need 3 pieces of information; 1) $q_{i,j}$; 2) source vertex if the $q_{i,j}$'s values are stored in the forward adjacency property lists, else destination vertex; and 3) the (list-level) postional offset of $e$ in that property list. For instance, in figure~\ref{fig:single-dir-prop-list}, \texttt{since} property of $e2$ can be accessed knowing $v4$ (source vertex of $e2$) and offest of $e2$ in $v4$'s forward adjecency property list, i.e 1. As was the case with global vertex ID, global edge IDs also cannot be used as the positional offset in the list to access a property. Hence, we adopt a new edge identification scheme that identifies the edge in the system by a tuple having 4 components: \textbf{\emph{(edge label, source vertex, destination vertex, list-level positional offset)}}. In our new scheme, the $e2$'s ID will be given as \texttt{FOLLOWS:v4:v1:2}, where $v4$ and $v1$ are the source and destination edges of $e2$. These edge IDs provides us with compact storage too. Most of the components need not to be stored in the adjacency lists and the edge ID can be constructed during query exection by reading as less as only the neighbour vertex's local positionl offset in the property list. 

\begin{figure}
	\vspace{-25pt}
	\hfill\includegraphics[scale=0.78]{img/edge-scheme}\hspace*{\fill}
	\captionsetup{justification=centering}
	\caption{Components of the new Edge identification scheme.}
	\label{fig:edge-scheme}
\end{figure}

\vspace{-12pt}
\subparagraph{Limitations.}Though single-directional adjacency property lists is as a good middleground solution, storing edge properties in property lists makes insertions costly if the edges are sorted in the adjacency lists. For example, assume a scenario where a new edge $e$ is inserted at \emph{position 5} in the forward adjacency list $A$ of vertex $v$ having a size \emph{10}. If the edge properties of $e$ are to be stored in the forward adjacency property lists of $v$, each property list will have to be rearranged. This will change the positional offset of the existing edges at location $\geq5$ in $A$. Updating the positional offsets of these edges in their occurance in the other adjacency list requires accessing and traversing $n$ adjacency lists, which is costly.

Apart from costly insertions, maintaining a pointer to a property list per edge property per vertex contributes significantly to the overall memory footprint for storing edges.

\vspace{-16pt}
\subparagraph{Modifications.}To make insertions easy, we omit the proposition of strict ordering in each vertex group of columns. By giving up ordering, queries no longer read the edge property values sequentially while extending from the adjacency list on which the group is ordered. However, we are still able to maintain cache locality by reading the property values from \emph{close-by} locations of a column.

We map $n$ ordered vertex groups from a vertex-grouped edge property column into one unordered page in paged edge property column. This way, a single page holds the property values from $n$ vertex groups. The mapping between vertex groups and page of respective columns is straightforward. Vertex groups of vertices having label-level positional offset $p$ maps to the $p/n$th page in the column. The main benefit of the paged edge property column comes from the fact that it is unordered. Hence, new edge insertions become easy as they get appended into relevant paged edge property column similar to how insertions happen in vertex property columns~\ref{sec:vertex-property-columns}. Property values in a page are still referenced by the group-level positional offset in the new edge identification scheme. However, group-level positional offset in paged edge property column no longer refers to the position of an edge in the ordering adjacency list. Now, the group-level positional offset only refers to the position of properties of an edge in paged edge property columns of a family. 

\begin{figure}
	\vspace{-40pt}
	\hfill\includegraphics[scale=0.78]{img/paged}\hspace*{\fill}
	\captionsetup{justification=centering}
	\caption{Mapping the Vertex-grouped edge property column to the Paged edge property column for since property in Figure~\ref{fig:runn}.Here, $n=2$.}
	\label{fig:paged}
	\vspace{-5pt}
\end{figure}

Figure~\ref{fig:paged} shows the mapping of a vertex-grouped edge property column to a paged edge property column for $n=2$. The paged edge property column has two pages that stores the property values from vertex groups $(v1,v2)$ and $(v3,v4)$ respectively.

The driving goal is to choose $n$ such that property values of edges in a defining adjacency list are not too sparse for a cache miss to occur with \emph{each} access of a value. Hence, the value of $n$ is heavily dependant on many factors like the cache line size, column element width and the average number of edges in the adjacency lists in the system. We choose the value of n in the range $32, 512$. We show in experiments that our solution is not significantly worse than the vertex-grouped edge property column when performing sequential reads. Comparing the two, we get a minimal overhead of 1.2x on read-intensive workloads. However, with completely unordered edge property column, the overhead over vertex-grouped edge property columns is as high as 4.5x.

\section{Adjacency Lists as a Column Store}
\label{sec:adjacency-lists}

The adjacency lists can be defined as a data-structure that maps a vertex $v$ to the list of $v$'s adjacent edges and neighbour vertices. Given a vertex $v$, t




\section{Storage optimizations}
\label{sec:storage-optimizations}

In this section, we present ideas on how our storage benefits (in terms of reducing the memory footprint) from the new identification schemes and structures that the data-structures introduced in previous sections. Our optimizations are critical in achieving high-levels of compactions while storing edges in the adjacency lists, thereby reducing the overall memory footprint of data in the system.

\subsection{Removing unnecessary edge information.}

The new edge identification scheme is \emph{virtual}. We do not need to store all the 4 components of the new edge identifier. While iterating on an adjacency list, the edge label of adjacent edge $e$ and the extending vertex ($e$'s source vertex in forward adjacency list and it's destination vertex in backward adjacency list) are already known and hence are not stored in the list. The neighbouring vertex ($e$'s destination vertex in forward adjacency list and source vertex in backward adjacency list) identifier is stored from prior. Therefore, the only storage overhead is the group-level positional offset. The offset is often not more than 1 or 2 bytes. This follows from the fact that the number of edges in most of the adjacency list is very small (by the power-law). Hence, storing the group-level positional offsets as a variable-width element saves memory by 2-3x. Moreover, in many cases, even group-level positional offsets can be omitted from storing in adjacency lists. We look at these cases in \ref{sec:storage-optimizations}.

At the time we introduced the new edge identification scheme in \ref{sec:edge-property-columns}, we briefly discussed the size of storing each edge in the adjacency lists. Out of 4 components in the new edge identifier, only 2 components, \emph{(neighbouring vertex, page-level positional offset)}, are needed to be stored per edge in the adjacency list. Note that the neighbouring vertex itself comprises of 2 components: \emph{(vertex type, type-level positional offset)}. Given that the vertex identifier is 12 bytes and page-level positional offset can be stored in 1 or 2 bytes, storing an edge in an adjacency list takes 14 bytes. We can omit to store the few components of the edge in the following cases: 

\begin{itemize}
	\item \textbf{Neighbouring vertex's type can be omitted while storing edges if it can be inferred implicitly.} We know by \ref{ssec:graph-schema}, that an edge label $l$ has a fixed set of source vertex types and destination vertex types. Using this, we can infer the \emph{probable set} of neighbouring vertex types, $T_N$, while extending a vertex. $T_N$ is defined as the set of vertex types whose vertices an extending vertex can extend to.

	Note that during the \texttt{E/I} operation, we already know, 1) the extending vertex, 2) \emph{direction} of extend, and 3) the edge label of edge we want to extend to. $T_N$ can be determined from the edge label and the direction of extend. If direction of extend is forward, $T_N$ is the destination vertex types of the edge label. Similarly, if direction is backward, source vertex types of the edge label forms $T_N$. 
	
	For cases when $|T_N|$ is $1$, the neighbouring vertex type in our extend operation is fixed. In these case, there is no need to store the neighbouring vertex types with \emph{all} the edges in adjacency list - and can be determined from the graph's schema. The following rules assist the omission of neighbour vertex types while storing edges:
	
	\begin{itemize}
		\item If edge label $l$ has only a source vertex type, then an edge $e$, from vertex $u$ to $v$ and having label $l$, can be stored without the neighbour vertex type in the backward adjacency lists of $v$.
		
		\item Similarly, if edge label $l$ has only a destination vertex type, then an edge $e$, from vertex $u$ to $v$ and having label $l$, can be stored without the neighbour vertex type in the forward adjacency lists of $u$.
	\end{itemize}

    \item \textbf{Edges that do not have properties, do not need page-level positional offsets.} From section \ref{sec:edge-property-columns} and \ref{sec:page-level-edge-property-columns}, we know that an edge's positional offsets is required \emph{only} while accessing its properties' value from relevant page-level edge property columns. Hence, in the absence of any properties on an edge, the (page-level) positional offset of that edge is undefined. Such edges are stored in the adjacency lists without any positional offsets information. In the absense of page-level positional offset, an edge cannot be identified globally since there can be multiple edge with unique \emph{(edge label, source vertex, destination vertex)} tuple. We reason that there is no requirement for an edge to be \emph{identifiable} in the system if not for accessing its properties. Conventionally, the purpose an  \texttt{edgeID} has been two-fold, 1) to connect source and destination vertices and, 2) to reference edge properties (if present). We are able to still fulfill 1) by not having a page-level positional offset while 2) stands void in the absence of properties. 
	
\end{itemize}

\subsection{Fixed-length null suppression}

The components of an edge identifier, usually, do not occupy the entire-width allocated to them in storage. For instance, a neighbouring vertex type is stored as a fixed 4-byte value in the adjacency lists. Likewise, neighbouring vertices' type-level positional offsets do not often exhaust the whole of 8 bytes allocated to them in storage. Clearly 


\subsection{Vertex property columns for single cardinality labels.}

Single cardinality labels are edge labels that have one of the following cardinalities, 1) 1..1 (one-to-one), 2) 1..n (one-to-many), and 3) n..1 (many-to-one). Such labels guarantee that there will be at most a single edge from the source vertex or to the destination vertex. For instance, let us consider an edge label BIRTHDAY that connects a vertex of type PERSON to the vertex of type DATE. Cardinality of BIRTHDAY is \emph{many-to-one}. That is, a vertex PERSON is connected to only one vertex of type DATE, while a vertex DATE can have connections to multiple PERSONs through the edge of label BIRTHDAY.

Single cardinality labels provide the opportunity of optimizing how the edges of such labels are stored. We use the fact that an edge $e$ of a single cardinality label is the \emph{only} element in either the forward adjacency list of $e$'s source vertex or forward adjacency list of $e$'s destination vertex or both. 

...

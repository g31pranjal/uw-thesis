
\chapter{Introduction}
\label{introduction}

The term \gls{gdbms}, in its contemporary usage, refers to data management software such as Neo4j \cite{neo4j}, JanusGraph~\cite{janusgraph}, TigerGraph~\cite{tigergraph}, and GraphflowDB~\cite{kankanamge:graphflow, mhedhbi:sqs}, that adopt the property graph data model~\cite{neo4j-property-graph-model}. In this model, application data is represented as a set of vertices, which represent the entities in the application, directed edges, which represent the relationships between entities, and arbitrary key-value properties on the vertices and edges, where both the relationships and key-value properties can depict different levels of structure.

\gls{gdbms}s have lately gained popularity to support a wide range of analytics applications, such as fraud detection, risk assessment in financial services and recommendations in e-commerce and social networks~\cite{sahu:survey}. These applications have read-heavy workloads that search for patterns in a graph-structured database, which often requires processing large amounts of data. In the context of \gls{rdbms}, column-oriented storage ({\em column stores})~\cite{monet-2decades, oracle-col, c-store, boncz-vectorwise} employ a set of storage, indexing, and query processing techniques to support traditional read-heavy analytics applications, such as business intelligence and reporting, that also process large amounts of data. As such, these columnar techniques are relevant for improving the performance and scalability of \gls{gdbms}s. In this thesis, we revisit columnar storage and query processing techniques and investigate their integration in \gls{gdbms}s. Specifically, we discuss the applicability of columnar storage techniques~\cite{c-store}, compression schemes for columns~\cite{abadi-col-comp, abadi-sparse-col, boncz-comp}, and block-oriented query processing~\cite{boncz-monet-vectorized, col-vs-row} for storing and accessing different components of GDBMSs. Even though analytical workloads that are run on \gls{gdbms}s and those on column-oriented \gls{rdbms} exhibit many similarities, they have different fundamental data access patterns. This calls for redesigning columnar techniques in the context of \gls{gdbms}.

We begin with a deep analysis of general query execution on graph data to understand data access patterns at the physical layer. We also identify different types of structures that can be present in graph data. We then utilize the results from these analyses to design the column-oriented physical data layout and implement new compressing and processing techniques. 

We first identify the storage components where in \gls{gdbms} where columnar storage can be directly integrated. For instance, columnar storage is directly applicable for storing vertex properties. Similarly, we use the popular compressed sparse row (CSR) or column (CSC) formats to store the topology of graphs, i.e., the edges between vertices, which is a variant of columnar data structures that store multi-value attributes and  employ a form of run-length encoding. In contrast to vertex properties, using columnar storage to store edge properties in a naive manner, using straightforward positional edge IDs, leads to a suboptimal solution which is not efficient for retrievals. We demonstrate this inefficiency and then, show an alternative design that improves the performance of queries that read edge properties. We follow a similar approach to evaluate the applicability of columnar compression techniques as well as query processing in \gls{gdbms} with columnar storage. For each, we review the approaches that exist and identify their shortcomings for our use case. Finally, we present our redesigned solution. 

\section{Contributions}

The specific contributions of this thesis are as follows:

\begin{itemize}
	\item \textbf{Guidelines and Desiderata:} Chapter~\ref{c:guidelines}, reviews the properties of data access patterns in GDBMSs, from which we derive a set of general guidelines and desiderata for designing the physical data layout of \gls{gdbms}s. We further explore the characteristics of real-world graph data and identify different types of structures that can exist in the graph data. The guidelines instruct where columnar techniques can be applied and some fundamental limitations about which type of data accesses can be localized in GDBMSs without data replication.
	
	\item \textbf{Columnar Storage:} In Chapter~\ref{c:columnar-storage}, we explore the application of columnar data structures for storing different components of \gls{gdbms}s. We start with components that can directly be stored in columnar structures, i.e., vertex properties and adjacency lists for many-to-many edges. Next, we identify the requirements from columnar data structures for edge properties and present two sub-optimal solutions that optimize storage and performance each. For each of the solution, we discuss their pros and cons. We then describe a third solution, \emph{single-directional property pages}, that sits in between the previously described 2 solutions and strikes a balance between storage and performance efficacy. Lastly, we show how single cardinality edges (having one-to-one, one-to-many and many-to-one edge labels) can be stored and referenced as the property of either source or destination vertex in vertex property columns. As we discuss in Chapter~\ref{c:evaluation}, storing these edges in vertex property columns can achieve huge storage and performance improvements.
	
	\item \textbf{New Vertex and Edge ID Scheme:} As a byproduct of switching to columns for storing properties, we introduce a new ID scheme for identifying vertex and edges in the system based on the positional offset of their properties. This allows for fast random access to properties in property columns. Besides, the new scheme presents immense opportunities to represent edges and vertices compactly in adjacency lists. For highly structured data, an edge and vertex can be together represented in adjacency list with a single value of a very small size. Our scheme, along with structural optimizations, can reduce the overhead of representing an edge and neighbour vertex to merely 6 bytes per edge.
	
	\item \textbf{Columnar Compression:} In Chapter~\ref{columnar-compression}, we discuss the application of existing columnar compression techniques in GDBMSs based on our guidelines. For each of the columnar techniques, we review its applicability and discuss where they can be applied in the columnar storage of \gls{gdbms}. Since a lot of property columns, as well as adjacent lists, can be sparse, we next review existing null compression techniques for columns and their shortcomings and describe a new null compression scheme, based on storing prefix sums, that address these shortcomings. We show that existing schemes would lead to very slow access in the context of \gls{gdbms}s. Our new null compression scheme allows constant-time access to any null or non-null property with a small increase in overhead per element. Our new null compression scheme can be applied to compress both null vertex properties as well as empty adjacency lists.
	
	\item \textbf{List-based Processing:} In Chapter~\ref{list-based-processing}, we review the query processing techniques used in \gls{gdbms} as well as in column-oriented \gls{rdbms}. We show that the volcano-style~\cite{volcano} query processing does not benefit from the order-aware arrangement data in our columnar data structures. On the other hand, column-at-a-time~\cite{col-vs-row} or vectorized~\cite{boncz-vectorwise1} query processors employed by several column stores do not adapt well to graph queries that have abundant join operations. To overcome the shortcomings, we introduce a new list-based query processor that processes the query per adjacency lists. Our new processor is a hybrid between volcano-styled and vectorized processing, that can operate on single value as well as one vector at a time. However, unlike vectorized processing, the vector in our case in variable-size and is equal to the size of an adjacency list.
\end{itemize}

We evaluate our work in Chapter~\ref{c:evaluation}. ...

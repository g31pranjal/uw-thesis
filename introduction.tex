
\chapter{Introduction}
\label{introduction}

The term \gls{gdbms}, in its contemporary usage, refers to data management software such as Neo4j \cite{neo4j}, JanusGraph~\cite{janusgraph}, TigerGraph~\cite{tigergraph}, and GraphflowDB~\cite{kankanamge:graphflow, mhedhbi:sqs}, that adopt the property graph data model~\cite{neo4j-property-graph-model}. In this model, application data is represented as a set of vertices, which represent the entities in the application, directed edges, which represent the relationships between entities, and arbitrary key-value properties on the vertices and edges, where both the relationships and key-value properties can depict different levels of structure.

\gls{gdbms}s have lately gained popularity to support a wide range of analytics applications, such as fraud detection, risk assessment in financial services and recommendations in e-commerce and social networks~\cite{sahu:survey}. These applications have read-heavy workloads that search for patterns in a graph-structured database, which often requires processing large amounts of data. In the context of \gls{rdbms}s column-oriented storage~\cite{monet-2decades, oracle-col, c-store, boncz-vectorwise} employ a set of storage, indexing, and query processing techniques to support traditional read-heavy analytics applications, such as business intelligence and reporting, that also process large amounts of data. As such, these columnar techniques are relevant for improving the performance and scalability of \gls{gdbms}s. In this thesis, we revisit columnar storage and query processing techniques and investigate their integration in \gls{gdbms}s. Specifically, we discuss the applicability of columnar storage techniques~\cite{c-store}, compression schemes for columns~\cite{abadi-col-comp, abadi-sparse-col, boncz-comp}, and vector-oriented query processing~\cite{boncz-monet-vectorized, col-vs-row} for storing and accessing different components of \gls{gdbms}s. Even though analytical workloads that are run on \gls{gdbms}s and those on column-oriented \gls{rdbms}s exhibit many similarities, they have different fundamental data access patterns. This calls for redesigning columnar techniques in the context of \gls{gdbms}s.

We begin with an analysis of general query execution on \gls{gdbms}s to understand data access patterns at the physical layer. We also identify different types of structure that can be present in graph data. This analysis gives us a set of guidelines and desiderata that instruct how to integrate and adopt columnar techniques in the context of \gls{gdbms}s. We first identify the storage components of a \gls{gdbms} where columnar storage can be directly integrated. For instance, columnar storage is directly applicable for storing vertex properties. Similarly, we use the popular compressed sparse row (CSR) or column (CSC) formats to store the topology of graphs, i.e., the edges between vertices, which are columnar data structures that store multi-value attributes, employing a form of run-length encoding. In contrast to vertex properties, we observe that using the straightforward columnar storage to store edge properties with global positional edge IDs leads to a suboptimal solution. Similarly we show that integrating existing null compression schemes from column-oriented \gls{rdbms}s and vector-oriented processing directly into \gls{gdbms}s is not appropriate and do not satisfy the set of desiderata we outline. We then describe new techniques that address the shortcomings of these techniques. We integrate all of our techniques into the GraphflowDB \gls{gdbms} and demonstrate that our techniques has increased the system's scalability significantly with performance benefits.
% which does not localize accesses. We demonstrate this inefficiency and then show an alternative design, which consists of edge property pages and a new edge ID scheme, that improves the performance of queries that read edge properties. We follow a similar approach to evaluate the applicability of columnar compression techniques as well as query processing in \gls{gdbms} with columnar storage. For each, we review the approaches that exist and identify their shortcomings for our use case. Finally, we present our redesigned solution. 

\section{Contributions}

The specific contributions of this thesis are as follows:

\begin{itemize}
	\item \textbf{Guidelines and Desiderata:} Chapter~\ref{c:guidelines} reviews the properties of data access patterns in \gls{gdbms}s, from which we derive a set of general guidelines and desiderata for designing the physical data layout of \gls{gdbms}s. We further explore the characteristics of real-world graph data and identify different types of structures that can exist in the graph data. The guidelines instruct the applicability of the columnar techniques we revisit in later chapters.% can be applied and some fundamental limitations about which type of data accesses can be localized in GDBMSs without data replication.
	
	\item \textbf{Columnar Storage:} Chapter~\ref{c:columnar-storage} explores the application of columnar data structures for storing different components of \gls{gdbms}s. We start with components that can directly be stored in existing columnar structures, specifically vertex properties and adjacency lists for many-to-many edges. Next, we identify the requirements in using columnar data structures for edge properties and present two initial solutions that optimize storage and performance, respectively. We discuss the pros and cons of both solutions and then describe a third solution, \emph{single-directional property pages}, that lies in between the previously described 2 solutions and strikes a good balance between storage and performance efficacy. Lastly, we show how single cardinality edges (having one-to-one, one-to-many and many-to-one edge labels) can be stored and referenced as the property of either source or destination vertex in vertex columns. %We experimentally demonstrate how storing these edges in vertex property columns can achieve huge storage and performance improvements in Chapter~\ref{c:evaluation}.
	
	\item \textbf{New Vertex and Edge ID Scheme:} We introduce new ID schemes for identifying vertex and edges, which can be used as positional offsets to access their properties stored in the columnar structures. This allows for fast random access to properties in property columns. Additionally, the new scheme allows representing edges and vertices in compressed form in adjacency lists. 
	%For the graph data that has structure, we can represent both an edge and a neighbour vertex together in adjacency list with a single value of a very small size. 
%	When storing the LDBC~\cite{ldbc} social network benchmark graph, our scheme, along with structural optimizations, reduces the overhead of representing an edge and neighbour vertex pair to merely 6.5 bytes per edge.
	
	\item \textbf{Columnar Compression:} In Chapter~\ref{columnar-compression}, we discuss the application of existing columnar compression techniques in \gls{gdbms}s based on our guidelines. For each of the columnar techniques, we review their applicability and discuss where in our columnar storage they can be applied. As property columns and adjacent lists can be sparse, we next review existing null compression techniques for columns and show the existing schemes would lead to very slow read accesses. We then describe a new null compression scheme, based on storing prefix sums of non-null values, that addresses this shortcoming. Our new null compression scheme can be used to compress both null edge and vertex properties, as well as empty adjacency while allowing constant-time access to any null or non-null property with a small increase in storage overhead per entry. 
	
	\item \textbf{List-based Processing:} In Chapter~\ref{list-based-processing}, we review the query processing techniques used in \gls{gdbms} as well as in column-oriented \gls{rdbms}s. We show that the traditional  Volcano-style~\cite{volcano} query processing does not benefit from the arrangement of data in our columnar data structures. On the other hand, column-at-a-time~\cite{col-vs-row} or vectorized~\cite{boncz-vectorwise1} query processors employed by several column stores do not adapt well to graph queries that have many many-to-many join operations. To overcome these shortcomings, we introduce a new list-based query processor that runs queries on entire adjacency lists at a time. Our new processor is a hybrid between Volcano-style and vectorized processing, that can operate on single values as well as entire lists at a time. However, unlike vectorized processing, the size of lists in our case are of variable length, depending on the number of adjacent edges of a particular vertex.
\end{itemize}

In Chapter~\ref{c:evaluation}, we present experiments on our columnar data structures and techniques to show the benefits in terms of memory usage and query performance. Chapter~\ref{c:related-works} presents related work in storage and compression techniques in the context of column-oriented \gls{rdbms}s and graph structured data management systems. Finally, Chapter~\ref{c:conclusion-future-work} concludes and outlines directions for future work.



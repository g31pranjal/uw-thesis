\chapter{Generel Guidelines for data access patterns in GDBMSs}
\label{guidelines}

In this chapter we analyze the storage components of a \gls{gdbms} and the system's primary operators to get a brief idea of data-access patterns. We then use the inferences of our study to draw a basic set of guidelines that helps us support our design ideas for our data-structures and query-processing techniques in later chapters.

We begin by briefly describing the \emph{Property Graph Data Model} in section \ref{sec:property-graph-data-model}, primary storage components of \gls{gdbms}s in section \ref{sec:storage-components} and query processing operators in \gls{gdbms}s in section \ref{sec:operators}. We finally end the chapter by stating the infered guidelines from our analysis in section \ref{sec:guidelines}.

\section{Property Graph Data Model}
\label{sec:property-graph-data-model}

A property graph consists of entities, called \emph{vertices}, and links that exist between two entities, called \emph{edges}. An edge in a graph \emph{always} has a well defined \emph{source} vertex, \emph{destination} vertex and a \emph{direction}. Each vertex belongs to a particular \emph{type}. Similarly, edges have a \emph{label}. Types and labels are high-level categorizations of vertices and edges respectively in a graph and helps to group together similar sets vertices and edges.

Similar to how entities in a relational table have values to attributes defined in the schema, vertices and edges in a graph can also have (attribute, value) pairs. These are called \emph{properties} of an entity. However unlike attributes in relational tables, the properties on a entity in graph is definite neither in occurance nor in value type throughout the graph. Therefore, vertices and edges can have any number of properties of arbitrary data type.

Figure \cite{property} gives an overview of how entities and properties are linked in a Property Graph data model.

\section{Primary storage components in GDBMSs}
\label{sec:storage-components}

Vertices and edges of a graph together forms its topology which is stored in a well-studied data structure called \emph{adjacency lists}. An adjacency list of a vertex is a map to vertex's direct set of edges and \emph{neighbouring} vertices. Typically in a \gls{gdbms}, each vertex is asscoiated with 2 adjacency lists - a \emph{forward adjacency list}, containing list of outward edges of that vertex, and a \emph{backward adjacency list} which holds the inward edges. It might be beneficial thinking of single-directional adjacency lists of all vertices as a relational table having 3 attributes, source vertex, destination vertex and edgeID, which is \emph{clustered} on either the source or destination vertex. Having adjacency lists in either directions, we can reach to the reach to the list of neighbours of a vertex through forward or backward edges in constant-lookup, which provides the core capability of fast joins to a \gls{gdbms}. 

Typically, a single-directional adjacency list if further clustered into sublists by the edge label of the edges. This enables the operation of joining a vertex to neighbour vertices and edges of a \emph{particular} label a constant-time lookup operation. The intuition behind the subgrouping is that most of the queries on graph have a given label on edges in the query. Similarly, the edges in the adjacency lists are more than often ordered according to some attribute of the edge or vertex, even edge properties or vertex properties.

Apart from adjacency lists, a \gls{gdbms} also have to store properties that appear on vertices and edges. There are multiple ways the properties of the system can be stored. Of all the easiest way is to store properties in a \emph{key-value store} where each property is indexed by the \emph{hash} of property's attribute name and 8-byte unique ID of the vertex or edge in the system. Properties can also be stored as a \emph{variable-sized} byte-encoded record of each vertex or edge - in a fashion similar to how row records are stored in row-based \gls{rdbms}. A record is essentially variable-sized owing to the fact that the number of properties on an entity is not fixed. Compared to a key-value store, searching for a property in variable-sized records is a daunting task that involves decoding and parsing the entire record till the match is found. Also, addition and deletion of properties is not straight-forward in records. Yet another way of storing properties is in a doubly linked-list that makes at least additions and deletions easy.

\section{Query execution in GDBMSs}
\label{sec:operators}

	First example


A user query $Q$ to \gls{gdbms} typically consist of 2 parts, 
a subggarh pattern $G_Q$ that natches the queried subgraph to identical occurances in the graph

\section{Guidelines}
\label{sec:guidelines}

% However, even though the GDBMSs do not support a schema, there is not complete heterogeneity in the properties appearing on nodes and relationships in real-world graph datasets. As a matter of fact, most of the properties are regular in terms of occurance and have a consistent type in all the nodes or realtionships of a particular type and label. By virtue of their occurance frequency and type consistency, we say a property to be structured or unstructured. These properties over entities in GDBMSs are stored in variety of data structures like a key-value store [? ], doubly linked-list [2] or a blob, and forms the other major compo- nent of GDBMS storage apart from the adjacency list.

% Nodes and Relationships can also have an arbitrary set of key-value properties on them in an essense similar to that of having attributes in a relational table, except relation

\subsection{Edges are doubly-indexed}
Each edge of the graph data is indexed twice in the system - once in the adjacency list of source vertex, called \emph{forward adjacency list}, and again in the adjacency list of destination vertex of that edge, called \emph{backward adjacency lists}. Having two adjacency lists per vertex in either direction is central to performing fast joins from a vertex to its neighbour vertices. Each entry in an adjacency lists holds 2 pieces of information: a neighbour vertexID and an edgeID. Though source and destination vertices can be resolved from the edge, we keep the neighbour \texttt{vertexID} as an additional piece of information in the adjacency list to avoid lookup. As evident, \texttt{edgeID}s are duplicated across the two set of adjacency lists. However, we cannot avoid the duplication at a zero-cost penalty to the joining capabilities of the system.

\subsection{Edges are read in an order from the adjacency list}
An adjacency list of a vertex is often further bifurcated into smaller lists which groups edges having same label. Accessing an adjacency list's sublist is a constant-time operation. Therefore, for a typical match query that aims at matching a vertex of type PERSON to neighbour vertices of type ORGANISATION through an edge having label WORKSAT, we can reach the relevant list of edges in the appropriate adjacency list directly. Edges in a matched \emph{sublist} is read by the extend operator in the order of their appearance in the sublist. Furthermore, if the query is required to read some or all of the edge properties of the edges, these properties are also read in the same order as that of the edges read from the adjacency list. 

The idea of orderly reads of edges and edge properies straightaway triggers the question if we can read them sequentially from the memory at once and hence benefit from the cache locality available at hand. However, There are two concerns achieving sequential access: 
\begin{enumerate}
	\item The edge properties should be organized in the order identical to that of edges in the adjacency list.
	\item The idea of sequential reads of edges \emph{does not} hold much relevance in the volcano-style processing in \gls{gdbms}s which match queries tuple-at-a-time.
\end{enumerate}

\subsection{Vertices cannot be ordered}

Contrary to how the edges and edge properties are accessed orderly during query execution based on the order in which edges appear in the adjacency lists, there is no definite ordered access pattern in which vertices and its properties are read. This is owing to the fact that in a single-directional adjacency lists, a neighbour vertex can appear \textit{n} number of times, where \textit{n} is the number of edges the vertex in that direction. Hence, a vertex can appear anywhere in adjacency lists, any number of times. Hence, set of verices cannot be ordered without replication. Moreover, similar concerns that exist with edges, are also valid for sequentially reading vertices.

\subsection{Graph data is not completely schema-agnostic}

Even thought linked data does not follow a well-defined schema, it is not completely schema-agnostic. It is possible to define a \emph{soft} schema on a graph data that captures much of the structuredness that is present in the dataset. The structuredness in the graph data can be attributed by the following rules:
\begin{itemize}
	\item Edge labels determine the source and destination vertex types of vertices connected by the edge of that label. For example, in the LDBC social network benchmark, edge label KNOWS only exists between vertices of type PERSON.
	\item Just like attributes of a relational table, properties and its data type on an edge/vertex can \emph{mostly} be determined by its edge label/vertex type. For example, a vertex of type PERSON in LDBC SNB has the following properties - firstName, lastName, gender etc. 
\end{itemize}

We say that properties cannot be completely determined 

\subsection{A query over graph data do touch all the edge/vertex properties}







